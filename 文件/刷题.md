# 刷题

## 一 基础数据结构与算法

### 双指针

这一块的话就是四个模板

最大，最小，方案数目

##### 双指针总结

总共可以分成最长上升子数组，最大值/最大长度，最小值/最小长度，方案数目





##### 子排列个数题



### 哈希表

注意复习字符串的知识

比如

StringBuilder res = new StringBuilder();

res.append("you");

for (Map.Entry<Character, Integer> entry : cnts.entrySet()) {

​      for (int i = 0; i < entry.getValue(); i++) {

​        res.append(entry.getKey());  // 将剩余的字符添加到结果字符串中

​      }

​    }



压缩数组这道题

怎么处理这个数组呢？

![image-20240715162652208](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240715162652208.png)

```Java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        s = s.substring(1, s.length() - 1);  // 去除首尾的括号
        String[] arr = s.split(",");  // 按照逗号分隔，每一对数字用哈希表来记录
        int num = 0, cnt = 0;
        List<String> res = new ArrayList<>();
        for (String x : arr) {
            int k = x.indexOf('(');
            int num1 = Integer.parseInt(x.substring(0, k));  // 找到对应的数字
            int cnt1 = Integer.parseInt(x.substring(k + 1, x.length() - 1));  // 找到对应的次数
            if (num1 != num) {
                if (cnt > 0) {
                    res.add(num + "(" + cnt + ")");
                }
                num = num1;
                cnt = cnt1;
            } else {
                cnt += cnt1;
            }
        }
        res.add(num + "(" + cnt + ")");  // 存最后一个数对
        System.out.println("[" + String.join(",", res) + "]");  // 按照题目输出要求输出
    }
}
```

##### 手办爱好者

**队列+哈希表模拟懒删除**

![image-20240715180415477](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240715180415477.png)

```
import java.util.*;

public class Main {
    static Map<String, Integer> mp = new TreeMap<>(); // 懒删除标识
    static Map<String, Integer> res = new TreeMap<>(mp);
    static Queue<Pair> q = new LinkedList<>(); // 排队队列，Pair中的String表示姓名，Integer表示加入队伍的时间
    static int cnt; // 记录排队的总人数
    static int n, m, t;

    static class Pair {
        String a;
        int b;

        Pair(String a, int b) {
            this.a = a;
            this.b = b;
        }
    }

    static void solve(int x) { // 找到队列最前面的一个人，并更新这个人购买的手办数量
        while (!q.isEmpty()) { // 直到找到一个mp[a] != -1的人
            Pair pair = q.peek();
            if (mp.get(pair.a) == pair.b) { // 队列最前面的人购买后直接返回
                res.put(pair.a, res.getOrDefault(pair.a, 0) + x);
                n -= x;
                return;
            }
            q.poll(); // 过滤掉已经离开队列的人
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        t = sc.nextInt();
        for (int i = 0; i < t; i++) {
            int op = sc.nextInt();
            if (op == 1) { // 将第i个人插入队尾
                String name = sc.next();
                mp.put(name, i);
                q.add(new Pair(name, i));
                cnt++;
            } else if (op == 2) { // 将第i个人从队列中懒删除
                String name = sc.next();
                mp.put(name, -1);
                cnt--;
            } else if (op == 3) { // 队列最前面的人购买了x个限定手办
                int x = sc.nextInt();
                solve(x);
                if (n <= m) { // 黄牛把所有手办都买走了
                    solve(n);
                    break;
                }
            } else {
                System.out.println(cnt);
            }
        }
        for (Map.Entry<String, Integer> entry : mp.entrySet()) {
            System.out.println(entry.getKey() + " " + res.getOrDefault(entry.getKey(), 0));
        }
    }
}
```



### 前缀和

朴素前缀和里面的相等数

前缀和-总结篇 前缀和在笔试中总共有三种题型：朴素前缀和（一维、二维）、前缀和+哈希表、前后缀分解三种题型。 这三类题型，笔试都有涉及，因此建议大家都要掌握 第一种题型，也是最简单的题型，大家直接把一维前缀和和二维前缀和的模版记住即可。 第二种题型，会稍微难理解一些，大家对着题单中的内容做一遍题目，然后不理解的地方可以看看其中的视频讲解，来加速自己理解的过程。 第三种题型，其实也算是一种动态规划+预处理的思想，套路性极强，做了两道题基本上就可以上手了，下面会在评论区分享一些关于前缀和的技巧和常见问题，以及一些理解性的东西，也欢迎大家来评论区交流讨论。

### 差分

### 二分



## 二 搜索与图论



## 三 动态规划



### 线性DP

##### 跳格子

![image-20240805142253389](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240805142253389.png)



蛮有意思的，要考虑到一个斐波那契数列，综合时间复杂度是mn

```
import java.util.*;

public class Main {
    static final int N = (int)2E5 + 10;
    static int n;
    static int[] a = new int[N];
    static long[] f = new long[N];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        for (int i = 1; i <= n; i++) a[i] = scanner.nextInt();
        List<Integer> b = new ArrayList<>(Arrays.asList(1, 1));   // 斐波那契数列
        for (int i = 2; b.get(b.size() - 1) <= n; i++) {
            b.add(b.get(i - 1) + b.get(i - 2));
        }
        int m = b.size();
        Arrays.fill(f, Long.MIN_VALUE);
        f[1] = a[1];
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < m; j++) {
                int k = i - b.get(j);
                if (k < 0) break;
                f[i] = Math.max(f[i], f[k] + a[i]);
            }
        }
        System.out.println(f[n]);
    }
}
```

#### 最长上升子序列/子数组类型

模板题;最长上升子序列

就是数组存储当前的最长子序列

```Java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            w[i] = scanner.nextInt();
        }
        int[] f = new int[n + 1];
        f[1] = 1;
        int res = 1;
        for (int i = 2; i <= n; i++) {
            if (w[i] > w[i - 1]) {
                f[i] = f[i - 1] + 1;
            } else {
                f[i] = 1;
            }
            res = Math.max(res, f[i]);
        }
        System.out.println(res);
    }
}
```

##### 模板题

###### 最大子数和

这个问题的话，是需要找一个连续的偶数区间，并且这个区间相加除以二能够使得数组总和最小，

即找一个最小的连续偶数区间

数组用来存储这个数组的最小连续区间和，然后每次比较，如果小于0，则加上【i-1】，如果大于0，就是当前数本身

可以引入双指针进行偶数的判断

```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n + 1];
        long[] f = new long[n + 1];  // 以第i个数字结尾的最大值
        long res = 0, total = 0;
        for (int i = 1; i <= n; i++) {
            w[i] = scanner.nextInt();
            total += w[i];
        }
        res = total;  // 将初始值设为数组总和
        for (int i = 1; i <= n; i++) {
            if (w[i] % 2 != 0) continue;  // 跳过奇数
            int j = i;  // 双指针算法，找到一个全是偶数的区间
            while (j <= n && w[j] % 2 == 0) {
                j++;
            }
            for (int k = i; k < j; k++) {
                f[k] = Math.min(0, f[k - 1]) + w[k];
                res = Math.max(res, total - f[k] / 2);
            }
            i = j - 1;  // 双指针移动
        }
        System.out.println(res);
    }
}
```

###### 最长上身子序列

直接设计一个n2时间复杂度的题目，这个的话就是，对于 每一个数，再循环比较所有他之前的数字，用以更新他的最长子序列长度

```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n+1];
        int[] f = new int[n+1];  // 以第i个数字结尾的最长上升子序列的长度
        for(int i=1; i<=n; i++) {
            w[i] = scanner.nextInt();
        }
        int res = 0;
        for(int i=1; i<=n; i++){
            f[i] = 1;  // 状态方程初始化
            for(int j=1; j<i; j++){  // 枚举所有比i下标小的位置j
                if(w[i] > w[j]){ // 更新f[i]
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
            res = Math.max(res, f[i]);
        }
        System.out.println(res);
    }
}
```

补充：合唱队形，就是找出最长的山字形序列，要找出i前面的最长子序列以及i后面的最长子序列，

最长上升子序列以及最长下降子序列

![image-20240730163325731](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240730163325731.png)



```Java
import java.util.Scanner;

public class Main {
    static final int N = 1000 + 10;
    static int n;
    static int[] w = new int[N];
    static int[] f = new int[N];  // 以第i个数字结尾的最长上升子序列的长度
    static int[] g = new int[N];  // 以第i个数字开头的最长下降子序列的长度

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        for (int i = 1; i <= n; i++) {
            w[i] = scanner.nextInt();
        }
        for (int i = 1; i <= n; i++) {
            f[i] = 1;  // 状态方程初始化
            for (int j = 1; j < i; j++) {  // 枚举所有比i下标小的位置j
                if (w[i] > w[j]) {  // 更新f[i]
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        for (int i = n; i >= 1; i--) {
            g[i] = 1;  // 状态方程初始化
            for (int j = n; j > i; j--) {  // 枚举所有比i下标大的位置j
                if (w[i] > w[j]) {  // 更新g[i]
                    g[i] = Math.max(g[i], g[j] + 1);
                }
            }
        }
        int res = n;
        for (int i = 1; i <= n; i++) {
            res = Math.min(res, n - (f[i] + g[i] - 1));
        }
        System.out.println(res);
    }
}
```



###### 最长子序列二

对于时间复杂度有要求，算是对之前子序列问题的优化吧，引入二分

![image-20240805152428262](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240805152428262.png)

利用贪心+动态规划的思想 再加二分查找

```
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] w = new int[n+1];
        for(int i=1; i<=n; i++) {
            w[i] = scanner.nextInt();
        }
        List<Integer> arr = new ArrayList<>();  // 最长上升子序列
        arr.add(w[1]);  // 子序列初始化
        for(int i=2; i<=n; i++){
            if(w[i] > arr.get(arr.size()-1)){  // 如果当前元素大于子序列中的最后一个元素，则把当前元素加入子序列中
                arr.add(w[i]);
            }
            else{
                int l=0, r=arr.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(arr.get(mid) >= w[i]) r=mid;
                    else l=mid+1;
                }
                arr.set(l, w[i]);//如果小于，就把之前的替换掉，因为返回的是size，所以不影响
                //根据贪心的思想，要找最长子序列，肯定开头的数要尽可能的小
            }
        }
        System.out.println(arr.size());
    }
}
```



友好城市是这道题的衍生，加入一个排序







###### 过河卒

二维DP模板题，就是需要对马的控制范围就行一个，设置一个局部变量，判断是否可以访问，如果再就false跳出循环

```Java
import java.util.*;
public class Main {
    static final int N = 1010;
    static final int mod = (int)1e9+7;
    static int[][] not_visited = new int[9][2];  //马所看守的八个坐标
    static long[][] f = new long[N][N];
    static int[] dx = {2,1,-1,-2,-2,-1,1,2,0}, dy = {1,2,2,1,-1,-2,-2,-1,0};  //马的八个方向和它自己所在的点
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();
        for(int i=0;i<9;i++){
            not_visited[i][0] = dx[i]+x2;
            not_visited[i][1] = dy[i]+y2;
        }
        f[0][0] = 1;
        for(int i=0;i<=x1;i++){
            for(int j=0;j<=y1;j++){
                boolean is_visited = true;
                for(int k=0;k<9;k++){
                    if(i==not_visited[k][0] && j==not_visited[k][1]){  //判断当前点是否被马监控
                        is_visited = false;
                        break;
                    }
                }
                if(is_visited){
                    if(i>0) f[i][j] = (f[i][j] + f[i-1][j]) % mod;
                    if(j>0) f[i][j] = (f[i][j] + f[i][j-1]) % mod;
                }
            }
        }
        System.out.println(f[x1][y1]);
    }
}
```

###### 走棋盘问题 





###### 整数拆分问题



D:\jiangyinwen1\code-resposity\new-lve-local\new-live\sdk\live-cache\src\main\java\com\jd\live\cache\local\LiveActivityConfigCacheManage.java

500+

### 序列DP

### 背包问题

### 树形DP



主要是动态规划和树







#### HOT100重温

寻找两个数组的中位数，要求时间复杂度log（m+n）

这题看到log要想到二分

先放着今天看完二分再回来

```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int left = (m + n + 1) / 2;
        int right = (m + n + 2) / 2;
        return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0;
    }

    // i: nums1的起始位置 j: nums2的起始位置
    public int findKth(int[] nums1, int i, int[] nums2, int j, int k) {
        if (i >= nums1.length)
            return nums2[j + k - 1];// nums1为空数组
        if (j >= nums2.length)
            return nums1[i + k - 1];// nums2为空数组
        if (k == 1) {
            return Math.min(nums1[i], nums2[j]);
        }
        int midVal1 = (i + k / 2 - 1 < nums1.length) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE;
        int midVal2 = (j + k / 2 - 1 < nums2.length) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE;
        if (midVal1 < midVal2) {
            return findKth(nums1, i + k / 2, nums2, j, k - k / 2);
        } else {
            return findKth(nums1, i, nums2, j + k / 2, k - k / 2);
        }
    }
}


```

#### 三数和问题

固定一个数，排序加双指针

```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int k = 0; k < nums.length - 2; k++){
            if(nums[k] > 0) break;
            if(k > 0 && nums[k] == nums[k - 1]) continue;
            int i = k + 1, j = nums.length - 1;
            while(i < j){
                int sum = nums[k] + nums[i] + nums[j];
                if(sum < 0){
                    while(i < j && nums[i] == nums[++i]);
                } else if (sum > 0) {
                    while(i < j && nums[j] == nums[--j]);
                } else {
                    res.add(new ArrayList<Integer>(Arrays.asList(nums[k], nums[i], nums[j])));
                    while(i < j && nums[i] == nums[++i]);
                    while(i < j && nums[j] == nums[--j]);
                }
            }
        }
        return res;
    }
}

作者：Krahets
链接：https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



背包问题 

又分 能不能装满背包，以及装满背包有几种方式

完全背包问题

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。





#### 背包问题总结

主要是01背包和完全背包

能不能填满

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：

问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下



遍历顺序：

01背包的话，一维数组只能先遍历物品再遍历背包

完全背包问题

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

#### 编辑距离问题

就是在求最大重复的基础上，增加增删改，用dp[i][j] 表示i-1,j-1的需要编辑的距离大小

遍历顺序从左往右从上往下

题型比如  

**判断子序列** 用一个数组求 最长重复长度，相等就加加，不等就前一位

不同子序列 求子序列的出现次数，这个

#### 树形DP

#### 线性DP

最长上升子序列啥的

子序列子数组问题总结

分为最长递增子序列/子数组  最长连续递增子数组/子序列  最长重复子序列/子数组





设计模式和排序要赶紧看一下了，周末把设计模式，排序，树以及RPC的面试题过一遍

主要还有数据库的八股以及java的八股，一点点看吧，8月主要笔试九月开始大规模面试





为什么concurrenthashmap不可以为null

拒绝策略



















``` 
HTTP_POOL_EXECUTE.execute  返回为空导致走兜底
```

```
liveSearchAssociationalWordV902   返回了真实数据啊
{
  "code": "0",
  "data": [
    "茶吧机",
    "茶具",
    "茶几",
    "茶杯",
    "茶叶",
    "茶",
    "茶壶",
    "茶几客厅",
    "茶水分离杯",
    "茶盘",
    "茶桌",
    "茶吧机京东自营",
    "茶具整套"
  ],
  "subCode": "0",
  "tranceId": "0f216270579540ec96a732181d94f285",
  "logid": "87b04a97c6bb4ccc824d1b4fcf451633"
}
```
