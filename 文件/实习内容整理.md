

## 实习内容整理



压测

参与  购物袋重构

完成需求ABtest实验

完成购物袋搜索

连麦接入风控

把连麦和看赚接入试金石写进去，然后把根据直播Id以及根据商品sku进行搜索也写进去maybe 

熟悉流程



累计代码提交3000+

对团队开发的流程有了更加深刻的理解，提升了自身的技术水平，学会了技术文档的编写，锻炼了开发的思维，更加注重程序的可维护性、模块化和可读性，是自己明白了快速学习新知识并将其运动到业务的重要性。

参与直播间购物袋模块优化，  

通过上述两个举措，完成购物袋性能升级，接口性能大大提升，TP999从1000左右ms 降低至**200ms以内**，性能提升达**80%+**，大促中支持近**1.5WQPS**，同时保持**100%高可用率**



1. 参与价格一致性治理，配合完成直播领域下价格一致性问题保障推进，对9个直播间内接口和6个列表类接口价格一致性进行排查，完成到手价接口对直播专享价和直播专享券的支持；在优化价格商品兜底文案需求中，对全部涉及价格接口的兜底效果进行了摸排；

完成AB实验需求



1.安排学习计划

重点安排学习java基础技术，尤其是线程和线程池的相关技术；缓存基础知识，JimdDB支持的数据结构和常用api；ducc配置中心相关知识，并尝试搭建一套zk服务；

2.配合一起完成直播领域下价格一致性问题保障推进

对9个直播间内接口和6个列表类接口价格一致性进行排查，确认需要继续改造的5个接口；在优化价格商品兜底文案需求中，对全部涉及价格接口，在异常情况下，价格兜底效果进行了摸排；

3.学习AB实验

讲解基础pin维度或uuid维度实验如何开发，以及怎么使用试金石进行试验。阅读组内其他同学开发的试金石封装工具；

4.版本迭代需求开发实战

安排独立承担完成两个简单的版本迭代需求，在需求过程中独自完成与产品的沟通、和其他研发同学的联调，并在指导下完成上线工作



2. **风控接入：**
   - 集成了风控系统，通过调用`RiskManagementService`接口评估用户的风险分数，确保连麦请求的安全性。
   - 根据风险分数的不同，动态调整连麦请求的处理逻辑，提高系统的安全性和用户体验。

3. **用户校验：**
   - 实现了用户登录态和实名认证校验，确保只有登录并通过实名认证的用户才能申请连麦。
   - 使用`UserInfoService`接口进行实名认证检查，并在未通过认证时引导用户进行认证。

4. **技术栈：**
   - Java，Spring Framework
   - 风控系统集成，用户信息服务

**成就与贡献：**

- 成功设计和实现了直播连麦功能，提高了用户互动体验。
- 通过接入风控系统，有效减少了潜在的安全风险，提升了系统的可靠性。
- 优化了用户校验流程，确保了系统的安全性和合规性。



以下是一段简历中描述你在实习期间进行AB实验开发和实现监听器的工作内容的示例：

---

### 实习经历

**公司名称**  
**实习职位**  
**实习时间**

#### 工作职责：
- 参与AB实验开发，设计并实现功能模块，确保实验过程的稳定性和准确性。
- 开发并维护AB测试工具类，使用Java进行编码，确保代码的高效和可读性。
- 实现了监听器，用于动态调整实验配置和日志上报机制，根据实验需求进行降级处理。
- 编写代码进行实验结果的获取和解析，并根据不同实验场景返回相应的实验结果。
- 使用Touchstone SDK进行实验配置和管理，确保实验数据的准确性和一致性。
- 处理实验参数的类型和默认值，确保实验配置的灵活性和扩展性。
- 解决实验过程中遇到的各种问题，确保实验顺利进行。

#### 主要成就：
- 成功开发并上线多个AB实验，提高了产品功能的验证效率和用户体验。
- 实现了动态日志上报机制，提升了系统的稳定性和可维护性。
- 通过代码优化和重构，提高了代码的可读性和维护性。

---

希望这段描述能帮助你更好地展示你的实习经历和技术能力。如果有其他具体要求或需要进一步修改的地方，请告诉我！

设计并实现了一个AB测试监听器（`AbTestListener`），用于实时监听和更新AB测试配置。
   - 使用`@LafValue`注解加载配置，并根据配置的变动动态调整本地缓存。
        - 实现了日志上报的降级处理逻辑，确保在降级状态下仅进行分流操作而不进行日志上报。
            - 通过`JsonMapper`实现配置对象的序列化和反序列化，确保配置变动后的数据一致性。

对于mysql数据库，采用的是一主二从 的主从架构

master replica rdonly



一面通过，1、对于redis的基本使用熟悉，了解锁过期的处理方式，给出redis的redisson锁和watchdog的方案，了解redis大key热key的解决方式。2、因为做的是大数据量的计算，所以对于多线程锁的机制，以及多线程结果处理的方式比较熟悉。3、mq消息队列使用过kafuka+mq+flink的方式处理过大数量的计算，对于mq的任务重试和丢失知道异步补偿方案。4、dubbo了解基本的交互调用，对于客户端服务端性能不一致问题排查有自己的思考 5、了解并且处理过线上fullgc的问题，基本的dump流程都了解。6、线程池调优经验比较少  7、表达比较顺畅，对于做过的东西有自己的思考和沉淀。比较不错，综上一面通过



对spring、rocketmq、es、 mysql分库分表、索引等原理及底层 实现机制都有不错的了解。 有负责核心系统的经验，对防刷限流、熔断、降级及 如何保证系统高可用有基础的理解。对数据异构后数据 一致性的问题也有一定思考。



##### redis

了解锁过期的处理方式，给出redis的redisson锁和watchdog的方案，了解redis大key热key的解决方式



所以对于多线程锁的机制，以及多线程结果处理的方式比较熟悉



mysql分库分表、索引等原理及底层 实现机制

### 直播改进

直播热卖标签好像没有

衣物直播很少，抖音直播营收大头来自女装，今年的话运动户外模块涨幅很大（40），京东客户群体男性居多，是否可以给运动户外品牌主播更多流量倾斜



#### AB实验构建

基于公司自研试金石框架，对项目使用的AB实验进行封装，基于后端埋点以及监听

##### 看赚活动梳理 

##### 看赚试金石封装梳理



技术方面    （学习了哪些技术组件，自己有没有去深挖）

RPC  JimDB   配置中心 灰度机制 测试环境搭建

代码风格方面   （如何写出易于维护的代码）

经过三个月的实习，在开发代码时学会了首先判断逻辑是否正确，一方面来说要考虑到变动是否影响旧版本、历史数据以及其他上游，另一方面也要考虑对空集合、空数据、计算数据的处理。对于接口的设计，需要考虑是否可以降级，以及灰度方案是否可行。

开发流程方面   （单元检测，打日志，Git团队合作）

在三个月的实习过程中熟悉了

1.git分支管理

 

对团队开发的流程有了更加深刻的理解，提升了自身的技术水平，学会了技术文档的编写，锻炼了开发的思维，更加注重程序的可维护性、模块化和可读性，累计代码提交3500+，对直播电商有点初步的了解。。  



整个封装的过程

首先第一版是  实验id由DUCC下发，实验灰度从DUCC下发改成试金石下发

之前是看赚直接用白名单和灰度，如果用户uuid的哈希值在灰度范围内，就会展示看赚icon

现在看赚是先从DUCC获得实验id，再把实验ID，UUID，以及forcebot封装进param，然后调用封装的abtest的getvalueMAP,获得ingray，判断是否在灰度内，如果在就展示



##### 试金石工具封装

###### V1

abtestmanage   用一个concurrentHashMap来存储ab实验的相关配置

监听器的话

```
这段Java代码定义了一个名为 `AbTestListener` 的类，该类似乎用于处理某种形式的配置更新，并将更新的配置信息同步到本地缓存中。以下是代码中各部分的解释：

1. `@Slf4j`：这是一个Lombok注解，它为这个类提供了一个日志对象（通常是名为 `log` 的 `Logger` 对象），用于记录日志。

2. `@Component`：这是Spring Framework的注解，它将这个类标记为Spring容器管理的组件，这意味着Spring将创建并管理这个类的一个实例。

3. `private static final JsonMapper MAPPER = JsonMapper.nonNullMapper();`：这行代码创建了一个 `JsonMapper` 对象，用于JSON序列化和反序列化操作。`nonNullMapper()` 方法可能表示这个映射器在序列化时会忽略所有值为null的字段。

4. `@LafValue(name = "ab_test_config")`：这个注解可能是一个自定义注解，用于将方法与某个配置值关联起来。这里它与名为 "ab_test_config" 的配置项关联。

5. `public void loadConfiguration(Configuration configuration)`：这是一个公共方法，它接收一个 `Configuration` 对象作为参数。这个方法首先使用 `changeLocalCacheConfigurationObject` 更新本地缓存，然后根据 `AbTestManage.isDowngrade` 方法的返回值来决定是否启用或禁用日志上报功能。

6. `private <T> void changeLocalCacheConfigurationObject(...)`：这是一个私有泛型方法，用于更新本地缓存。它接受一个 `Configuration` 对象、一个本地缓存映射和一个类对象 `Class<T>` 作为参数。它会遍历所有配置属性，并将它们更新到本地缓存映射中。如果配置中的某个键被删除，则相应的本地缓存也会被删除。

7. `private <T> void changeLocalCachePropertyObject(...)`：这是另一个私有泛型方法，用于更新本地缓存中的单个属性。它会检查传入的 `Property` 对象是否为空，然后更新本地缓存映射，只有当新值和旧值不相同时才会更新。

整体上，这个类是一个配置监听器，它监听配置更改，将配置信息同步到本地缓存，并可能控制日志上报的行为。代码中有几个自定义的类和方法（如 `AbTestManage`、`AbTestEnum`、`AbTestToolUtils` 和 `Configuration`），这些不是Java标准库的一部分，而是特定于这段代码所属应用或框架的。
```



工具类的话是

```

@Slf4j
public class AbTestToolUtils {

    private static final JsonMapper MAPPER = JsonMapper.nonEmptyMapper();

    private static final TouchstoneSDK TOUCHSTONE_SDK;

    static {
        Properties properties = new Properties();
        // 将配置加载逻辑封装到一个方法中
        loadProperties(properties);

        String productLine = properties.getProperty("abtest.productLine");
        int expireTime = Integer.parseInt(properties.getProperty("abtest.expireTime", "60"));
        int cacheMaxSize = Integer.parseInt(properties.getProperty("abtest.cacheMaxSize", "100"));

        TouchstoneSdkConfig config = new TouchstoneSdkConfig(expireTime, TimeUnit.SECONDS, cacheMaxSize);
        log.info("productLine 值为：{}， expireTime 值为：{}, cacheMaxSize 值为：{}", productLine, expireTime, cacheMaxSize);
        TOUCHSTONE_SDK = TouchstoneSDK.getInstance();
        TOUCHSTONE_SDK.init(productLine, config);

    }

    private static void loadProperties(Properties properties) {
        try (InputStream input = AbTestToolUtils.class.getClassLoader().getResourceAsStream("application.properties")) {
            if (input == null) {
                throw new RuntimeException("无法找到 application.properties 文件");
            }
            properties.load(input);
        } catch (IOException ex) {
            throw new RuntimeException("加载 application.properties 文件时发生错误", ex);
        }
    }

    /**
     * 当日志上报降级后，需要重制SDK中config下 enableLog2Disk = false (默认情况下是true，开启日志上报)
     */
    public static void loadSDK(boolean isDowngrade) {
        // 初始化后才会修改是否上报日志，否则不啥也不做
        if (TOUCHSTONE_SDK != null) {
            TouchstoneSdkConfig touchstoneSdkConfig = TOUCHSTONE_SDK.getTouchstoneSdkConfig();
            // 当降级时，如果config 中enableLog2Disk是true，需要置为false，不上报日志， 如果是false，则已经是不上报日志状态，不用管
            if (isDowngrade) {
                touchstoneSdkConfig.setEnableLog2Disk(Boolean.FALSE);
                TOUCHSTONE_SDK.setTouchstoneSdkConfig(touchstoneSdkConfig);
                log.warn("TOUCHSTONE_SDK 上报降级，enableLog2Disk 修改为false，只分流，不上报");
            } else {
                touchstoneSdkConfig.setEnableLog2Disk(Boolean.TRUE);
                TOUCHSTONE_SDK.setTouchstoneSdkConfig(touchstoneSdkConfig);
                log.warn("TOUCHSTONE_SDK 上报降级恢复，enableLog2Disk 修改为true，既分流也上报");
            }
        } else {
            log.warn("TOUCHSTONE_SDK 还未初始化，不修改上报属性");
        }
    }


    /**
     * 试金石实验，默认情况下已经是上报埋点，
     * 如果不需要设置埋点，需要在ducc 中配置关闭埋点上报(这是全局控制，没有根据实验设置的)
     *
     * @param experimentId 试金石平台id
     * @param param        试金石分流参数
     * @return
     */
    public static AbTestResult getABResult(String experimentId, AbTestParam param) {
        try {
            if (AbTestManage.isDowngrade(AbTestEnum.AB_TEST_SDK_DOWN)) {
                log.warn("试金石SDK降级!");
                return null;
            }
            if (StringUtils.isAllEmpty(param.getUuid(), param.getPin())) {
                log.warn("分流实验需要的pin/uuid 都为空，不参与实验");
                return null;
            }
            UserInfo userInfo = new UserInfo();
            if (StringUtils.isNotEmpty(param.getPin())) {
                userInfo.setUserPin(param.getPin());
            }
            if (StringUtils.isNotEmpty(param.getUuid())) {
                userInfo.setUuid(param.getUuid());
            }
            // 压测参数， 默认时线上  0 线上; 1 压测
            userInfo.setForceBot(StringUtils.equals("1", param.getForcebot()) ? 1 : 0);
            Map<String, ExpLabel> expParam = new HashMap<>();
            //默认兜底配置
            expParam.put(experimentId, new ExpLabel("base"));
            // 后端埋点(通过log埋点)
            Map<String, ExpLabel> labelRes = TOUCHSTONE_SDK.getExpLabelAndReportByLog(userInfo, expParam);
            log.info("试金石平台返回结果：{}", MAPPER.toJson(labelRes));
            if (MapUtils.isNotEmpty(labelRes) && labelRes.containsKey(experimentId)) {
                ExpLabel expLabel = labelRes.get(experimentId);
                if (Objects.nonNull(expLabel)) {
                    boolean inGray = false;
                    Map<String, Object> values = new HashMap<>();
                    // 是否是命中/不明中灰度场景
                    if (param.getYOrN()) {
                        // 简单的命中/不明中场景，没有values
                        inGray = TOUCHSTONE_SDK.getBooleanValue(experimentId, expLabel, "inGray", false);
                    } else {
                        // 非上述场景，需要自行通过fieldName来获取value
                        getValues(experimentId, expLabel, param, values);
                    }
                    return new AbTestResult(inGray, expLabel.getLabel(), values);
                }
            }
        } catch (Exception e) {
            log.error("获取试金石实验结果失败！experimentId：{}", experimentId, e);
        }
        return null;
    }

    private static void getValues(String experimentId, ExpLabel expLabel, AbTestParam param, Map<String, Object> values) {
        try {
            // 没有参数名称或没有参数类型时，获取实验下面所有的参数值
            if (StringUtils.isEmpty(param.getFieldName()) || Objects.isNull(param.getFieldType())) {
                // int 类型参数
                Map<String, Integer> intValues = TOUCHSTONE_SDK.getIntValues(experimentId, expLabel.getLabel());
                if (MapUtils.isNotEmpty(intValues)) {
                    values.putAll(intValues);
                }
                // boolean 类型参数
                Map<String, Boolean> booleanValues = TOUCHSTONE_SDK.getBooleanValues(experimentId, expLabel.getLabel());
                if (MapUtils.isNotEmpty(booleanValues)) {
                    values.putAll(booleanValues);
                }
                // double 类型参数
                Map<String, Double> doubleValues = TOUCHSTONE_SDK.getDoubleValues(experimentId, expLabel.getLabel());
                if (MapUtils.isNotEmpty(doubleValues)) {
                    values.putAll(doubleValues);
                }
                // String 类型参数
                Map<String, String> stringValues = TOUCHSTONE_SDK.getStringValues(experimentId, expLabel.getLabel());
                if (MapUtils.isNotEmpty(stringValues)) {
                    values.putAll(stringValues);
                }
            } else {
                // 有参数名称和类型时指定结果
                switch (param.getFieldType()) {
                    case 0:
                        Integer intValue = TOUCHSTONE_SDK.getIntValue(experimentId, expLabel, param.getFieldName(), Integer.valueOf(param.getDefaultValue()));
                        values.put(param.getFieldName(), intValue);
                        break;
                    case 1:
                        Boolean booleanValue = TOUCHSTONE_SDK.getBooleanValue(experimentId, expLabel, param.getFieldName(), Boolean.valueOf(param.getDefaultValue()));
                        values.put(param.getFieldName(), booleanValue);
                        break;
                    case 2:
                        Double doubleValue = TOUCHSTONE_SDK.getDoubleValue(experimentId, expLabel, param.getFieldName(), Double.valueOf(param.getDefaultValue()));
                        values.put(param.getFieldName(), doubleValue);
                        break;
                    case 3:
                        String stringValue = TOUCHSTONE_SDK.getStringValue(experimentId, expLabel, param.getFieldName(), param.getDefaultValue());
                        values.put(param.getFieldName(), stringValue);
                        break;
                    default:
                        break;
                }
            }
        } catch (Exception e) {
            log.error("获取试金石参数值异常: ", e);
        }
    }

}

```

```
这个Java工具类名为 `AbTestToolUtils`，主要用于与试金石（Touchstone）实验平台进行交互，从而实现AB测试的功能。AB测试是一种在线实验方法，通过将用户随机分配到不同的实验组（例如A组和B组）来比较不同版本的产品或功能的效果。下面是该工具类的详细解释：

1. **类注解 `@Slf4j`**：
   这是一个Lombok库提供的注解，它在编译时为类自动生成日志对象（默认是`log`），这样你就可以在类中直接使用`log`来记录日志，而不需要手动创建日志对象。

2. **静态变量**：
   - `MAPPER`：是一个 `JsonMapper` 对象，用于将对象转换为JSON字符串或将JSON字符串转换为对象。
   - `TOUCHSTONE_SDK`：是试金石SDK（Software Development Kit）的一个实例，用于与试金石服务进行通信。

3. **静态初始化块**：
   在类加载时执行，用于初始化 `TOUCHSTONE_SDK`。它首先加载 `application.properties` 配置文件，然后使用这些配置来初始化SDK。配置文件中包括产品线（`productLine`）、过期时间（`expireTime`）和缓存大小（`cacheMaxSize`）等配置项。

4. **方法 `loadProperties(Properties properties)`**：
   这是一个私有静态方法，用于从类路径下加载 `application.properties` 配置文件。如果文件不存在或者读取过程中发生错误，会抛出运行时异常。

5. **方法 `loadSDK(boolean isDowngrade)`**：
   这个公共静态方法用于根据是否降级来设置SDK的日志上报策略。如果降级（`isDowngrade` 为 `true`），则会关闭日志上报；否则，会开启日志上报。

6. **方法 `getABResult(String experimentId, AbTestParam param)`**：
   这是一个核心方法，用于获取AB测试的结果。它接受实验ID和分流参数作为输入，然后根据用户信息（例如 `pin` 和 `uuid`）和其他配置，从试金石SDK获取实验结果。如果成功，它会返回一个 `AbTestResult` 对象，其中包含了实验结果的详细信息，例如是否在灰度测试中（`inGray`）、实验标签（`label`）和其他实验参数值。

7. **方法 `getValues(String experimentId, ExpLabel expLabel, AbTestParam param, Map<String, Object> values)`**：
   这是一个私有静态方法，用于从试金石SDK中获取特定实验的参数值。根据传入的参数类型，它可以获取整数、布尔值、双精度浮点数和字符串类型的参数值。

整体来说，`AbTestToolUtils` 类封装了与试金石实验平台的交互逻辑，提供了一套方便的方法来进行AB测试的配置和结果获取。它通过读取配置文件来初始化SDK，并提供了方法来调整日志上报策略以及获取实验结果。
```



看赚活动接入试金石就是

原有方案是判断用户pin是不是在白名单内，现在是判断是否是在实验中



### 风险排查流程



![image-20240726113017213](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240726113017213.png)

网关报警

点进去UMP监控显示![image-20240726113451170](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240726113451170.png)

然后回到自己的UMP监控查询报警的接口名字

![image-20240726114531810](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240726114531810.png)

然后点进去看监控，再直接点线图进去

![image-20240726115509021](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240726115509021.png)



![image-20240726115658609](C:\Users\jiangyinwen1\AppData\Roaming\Typora\typora-user-images\image-20240726115658609.png)





## 答辩述职

1.实习以来的业绩产出/工作成果？

1.价格一致性治理

2.试金石实验文档输出

3.商品查询小工具



2.发现的问题





3.团队贡献

1.两篇文档

2.内推一名jdy，offer人数1





讲解列表怎么知道有没有下一页

